{
  "address": "0x8D8D982DFC974A9F81F68DCfA1E42be540673877",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "amountIn",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amountOut",
          "type": "uint256"
        }
      ],
      "name": "exchangeRate",
      "outputs": [
        {
          "internalType": "int256",
          "name": "exchange",
          "type": "int256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "unsigned",
          "type": "uint256"
        }
      ],
      "name": "safeUnsignedToSigned",
      "outputs": [
        {
          "internalType": "int256",
          "name": "",
          "type": "int256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    }
  ],
  "transactionHash": "0x038cb9de1fa392edf8e516f33aed5c070ffcb40fcf27141afb11e8f7f798961a",
  "receipt": {
    "to": null,
    "from": "0xf73d7f5A890a131f12E4fB03E50277c49748Cf5E",
    "contractAddress": "0x8D8D982DFC974A9F81F68DCfA1E42be540673877",
    "transactionIndex": 3,
    "gasUsed": "250406",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x1b673cef8df3cec14bda442e4dc60c47ff18486df063a58b5ed37cf406648c06",
    "transactionHash": "0x038cb9de1fa392edf8e516f33aed5c070ffcb40fcf27141afb11e8f7f798961a",
    "logs": [],
    "blockNumber": 8263733,
    "cumulativeGasUsed": "672053",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "solcInputHash": "012008fbf0d13dacd607bc58cc486cfe",
  "metadata": "{\"compiler\":{\"version\":\"0.8.0+commit.c7dfd78e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"name\":\"exchangeRate\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"exchange\",\"type\":\"int256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"unsigned\",\"type\":\"uint256\"}],\"name\":\"safeUnsignedToSigned\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"stateVariables\":{\"SCALE\":{\"details\":\"How many trailing decimals can be represented.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/OpenMath.sol\":\"OpenMath\"},\"evmVersion\":\"istanbul\",\"libraries\":{\":__CACHE_BREAKER__\":\"0x00000000d41867734bbee4c6863d9255b2b06ac1\"},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":5000},\"remappings\":[]},\"sources\":{\"contracts/OpenMath.sol\":{\"content\":\"// SPDX-License-Identifier: ISC\\n\\n//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.0;\\n\\nlibrary OpenMath {\\n  uint256 constant MAX_UINT = 2**256 - 1;\\n  uint256 constant DECIMALS_UINT = 10**18;\\n  int256 constant DECIMALS_SIGNED = 10**18;\\n  int256 constant MAX_INT = 2**255 - 1;\\n  uint256 internal constant HALF_SCALE = 5e17;\\n\\n  /// @dev How many trailing decimals can be represented.\\n  int256 internal constant SCALE = 1e18;\\n\\n  /// @notice Finds the zero-based index of the first one in the binary representation of x.\\n  /// @dev See the note on msb in the \\\"Find First Set\\\" Wikipedia article https://en.wikipedia.org/wiki/Find_first_set\\n  /// @param x The uint256 number for which to find the index of the most significant bit.\\n  /// @return msb The index of the most significant bit as an uint256.\\n  function mostSignificantBit(uint256 x) internal pure returns (uint256 msb) {\\n    if (x >= 2**128) {\\n      x >>= 128;\\n      msb += 128;\\n    }\\n    if (x >= 2**64) {\\n      x >>= 64;\\n      msb += 64;\\n    }\\n    if (x >= 2**32) {\\n      x >>= 32;\\n      msb += 32;\\n    }\\n    if (x >= 2**16) {\\n      x >>= 16;\\n      msb += 16;\\n    }\\n    if (x >= 2**8) {\\n      x >>= 8;\\n      msb += 8;\\n    }\\n    if (x >= 2**4) {\\n      x >>= 4;\\n      msb += 4;\\n    }\\n    if (x >= 2**2) {\\n      x >>= 2;\\n      msb += 2;\\n    }\\n    if (x >= 2**1) {\\n      // No need to shift x any more.\\n      msb += 1;\\n    }\\n  }\\n\\n  /// @notice Calculates the binary logarithm of x.\\n  ///\\n  /// @dev Based on the iterative approximation algorithm.\\n  /// https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation\\n  ///\\n  /// Requirements:\\n  /// - x must be greater than zero.\\n  ///\\n  /// Caveats:\\n  /// - The results are nor perfectly accurate to the last digit, due to the lossy precision of the iterative approximation.\\n  ///\\n  /// @param x The signed 59.18-decimal fixed-point number for which to calculate the binary logarithm.\\n  /// @return result The binary logarithm as a signed 59.18-decimal fixed-point number.\\n  function log2(int256 x) internal pure returns (int256 result) {\\n    require(x > 0);\\n    unchecked {\\n      // This works because log2(x) = -log2(1/x).\\n      int256 sign;\\n      if (x >= SCALE) {\\n        sign = 1;\\n      } else {\\n        sign = -1;\\n        // Do the fixed-point inversion inline to save gas. The numerator is SCALE * SCALE.\\n        assembly {\\n          x := div(1000000000000000000000000000000000000, x)\\n        }\\n      }\\n\\n      // Calculate the integer part of the logarithm and add it to the result and finally calculate y = x * 2^(-n).\\n      uint256 n = mostSignificantBit(uint256(x / SCALE));\\n\\n      // The integer part of the logarithm as a signed 59.18-decimal fixed-point number. The operation can't overflow\\n      // because n is maximum 255, SCALE is 1e18 and sign is either 1 or -1.\\n      result = int256(n) * SCALE;\\n\\n      // This is y = x * 2^(-n).\\n      int256 y = x >> n;\\n\\n      // If y = 1, the fractional part is zero.\\n      if (y == SCALE) {\\n        return result * sign;\\n      }\\n\\n      // Calculate the fractional part via the iterative approximation.\\n      // The \\\"delta >>= 1\\\" part is equivalent to \\\"delta /= 2\\\", but shifting bits is faster.\\n      for (int256 delta = int256(HALF_SCALE); delta > 0; delta >>= 1) {\\n        y = (y * y) / SCALE;\\n\\n        // Is y^2 > 2 and so in the range [2,4)?\\n        if (y >= 2 * SCALE) {\\n          // Add the 2^(-m) factor to the logarithm.\\n          result += delta;\\n\\n          // Corresponds to z/2 on Wikipedia.\\n          y >>= 1;\\n        }\\n      }\\n      result *= sign;\\n    }\\n  }\\n\\n  function safeUnsignedToSigned(uint256 unsigned) public pure returns (int256) {\\n    require(\\n      unsigned < uint256(2**256 - 1),\\n      \\\"Unsigned integer is too large, conversion will result in a negative number\\\"\\n    );\\n    return int256(unsigned);\\n  }\\n\\n  // Returns exchange rate as a 59.18 decimal integer\\n  function exchangeRate(uint256 amountIn, uint256 amountOut)\\n    public\\n    pure\\n    returns (int256 exchange)\\n  {\\n    int256 numerator = safeUnsignedToSigned(amountIn);\\n    int256 denominator = safeUnsignedToSigned(amountOut);\\n\\n    exchange = (numerator * DECIMALS_SIGNED) / denominator;\\n  }\\n}\\n\",\"keccak256\":\"0x59d379d7be6ea6cf63056768177131f74f06b370777bd684c47dfb82fea75fa3\",\"license\":\"ISC\"}},\"version\":1}",
  "bytecode": "0x61039961003a600b82828239805160001a60731461002d57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600436106100405760003560e01c80633bfb3c6914610045578063ed7248041461006e575b600080fd5b61005861005336600461012a565b610081565b6040516100659190610163565b60405180910390f35b61005861007c366004610142565b6100e9565b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82106100e5576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016100dc9061016c565b60405180910390fd5b5090565b6000806100f584610081565b9050600061010284610081565b905080610117670de0b6b3a76400008461027c565b61012191906101ef565b95945050505050565b60006020828403121561013b578081fd5b5035919050565b60008060408385031215610154578081fd5b50508035926020909101359150565b90815260200190565b6020808252604a908201527f556e7369676e656420696e746567657220697320746f6f206c617267652c206360408201527f6f6e76657273696f6e2077696c6c20726573756c7420696e2061206e6567617460608201527f697665206e756d62657200000000000000000000000000000000000000000000608082015260a00190565b600082610223577f4e487b710000000000000000000000000000000000000000000000000000000081526012600452602481fd5b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff83147f80000000000000000000000000000000000000000000000000000000000000008314161561027757610277610334565b500590565b60007f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff818413828413858304851182821616156102bb576102bb610334565b7f8000000000000000000000000000000000000000000000000000000000000000848712868205881281841616156102f5576102f5610334565b85871292508782058712848416161561031057610310610334565b8785058712818416161561032657610326610334565b505050929093029392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fdfea2646970667358221220bf7e1f53d3c13e3237052c2782eb23f9a34aa42e33cf5a6bf4e5e0aa542b08c864736f6c63430008000033",
  "deployedBytecode": "0x73000000000000000000000000000000000000000030146080604052600436106100405760003560e01c80633bfb3c6914610045578063ed7248041461006e575b600080fd5b61005861005336600461012a565b610081565b6040516100659190610163565b60405180910390f35b61005861007c366004610142565b6100e9565b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82106100e5576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016100dc9061016c565b60405180910390fd5b5090565b6000806100f584610081565b9050600061010284610081565b905080610117670de0b6b3a76400008461027c565b61012191906101ef565b95945050505050565b60006020828403121561013b578081fd5b5035919050565b60008060408385031215610154578081fd5b50508035926020909101359150565b90815260200190565b6020808252604a908201527f556e7369676e656420696e746567657220697320746f6f206c617267652c206360408201527f6f6e76657273696f6e2077696c6c20726573756c7420696e2061206e6567617460608201527f697665206e756d62657200000000000000000000000000000000000000000000608082015260a00190565b600082610223577f4e487b710000000000000000000000000000000000000000000000000000000081526012600452602481fd5b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff83147f80000000000000000000000000000000000000000000000000000000000000008314161561027757610277610334565b500590565b60007f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff818413828413858304851182821616156102bb576102bb610334565b7f8000000000000000000000000000000000000000000000000000000000000000848712868205881281841616156102f5576102f5610334565b85871292508782058712848416161561031057610310610334565b8785058712818416161561032657610326610334565b505050929093029392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fdfea2646970667358221220bf7e1f53d3c13e3237052c2782eb23f9a34aa42e33cf5a6bf4e5e0aa542b08c864736f6c63430008000033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "stateVariables": {
      "SCALE": {
        "details": "How many trailing decimals can be represented."
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}